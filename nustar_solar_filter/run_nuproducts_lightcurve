#!/usr/local/bin/perl -w

=head1 NAME

run_nuproducts_lightcurve - A simple wrapper for nuproducts that only generates a lightcurve

=head1 SYNOPSIS

  run_nuproducts_lightcurve.pl PATH-To-FILE [options]

  Help Options:
   --help     Show this scripts help information.
   --manual   Read this scripts manual.
   --version  Show the version number and exit.

=cut


=head1 OPTIONS

=over 8

=item B<--binsize>
The bin size (in seconds) that you want to use.

=item B<--region>
The full path to a ds9 region file that you want to use to generate the lightcurve.

=item B<--usrgti>
The full path to a user-specific GTI file.

=item B<--barycorr>
Toggle for whether or not you want to apply barycorr

=item B<--erange>
The energy range (in keV) that you want to use to generate the lightcurve (default is 3 to 79 keV).

=item B<--outdir>
Output directory (default is ./)

=item B<--help>
Show the brief help information.

=item B<--manual>
Read the manual, with examples.

=item B<--version>
Show the version number and exit.

=back

=cut


=head1 EXAMPLES

  The following is an example of this script:

 run_nuproducts_lightcurve 80001085002/event_cl/nu80001085002A01_cl.evt.gz --erange 3 20 --region 80001085002/event_cl/src.reg --binsize 100

=cut


=head1 DESCRIPTION

This is a simple script that makes it easy to call nuproducts with the appropriate flags to make a lightcurve.
It also knows how to parse out some option so that you can specify a region that you want to use to spatially
filter the lightcurve and an energy range 

=cut


=head1 AUTHOR


 Brian Grefenstette
 --
 http://www.briangrefenstette.com/
 bwgref@srl.caltech.edu

 $Id: run_nuproducts_lightcurve,v 0.01 2015/04/30 14:21:01  $

=cut


use strict;
use Getopt::Long;
use warnings;
use Pod::Usage;
use File::Basename;

use feature qw(say);


my $BINSIZE = 0;
my $REGION='' ;
my $USRGTI='';
my $BARYCORR= 0 ;
my @ERANGE = ();
my $PID=$$;
my $OUTDIR='./';

#
# Release number.
#
my $RELEASE = '0.01';


# Check to see if the HEASoft has been initialized
my $headas_test=$ENV{'HEADAS'};
die "Please initialize the HEASoft first" unless ($headas_test ne "") ;


#
#  Parse command line arguments.  These override the values from the
# configuration file.
#
parseCommandLineArguments();

# See if you have anything left. If you don't have one file, then show the help:
my $num_args =0 ;
$num_args = @ARGV;
pod2usage(1) unless($num_args == 1);

my $fullname=$ARGV[0];

# See if the file exists:
die "File does not exist: $fullname" unless (-e $fullname);


# Parse filename
my $evtfile;
my $path;
my $suffix;
my $FPM;
($evtfile,$path, $suffix) = fileparse($fullname, (".evt", ".evt.gz"));
say $evtfile;
if ($evtfile =~ /A/){
    $FPM="FPMA";
} else {
    $FPM="FPMB";
}
say $FPM;
#say $path;
#say $suffix;

# Put a PFILES temporary directory in the local path:
my $OLD_PFILES='temp';
$OLD_PFILES = $ENV{'PFILES'};
my $NEW_PFILES="$OUTDIR$PID";
if (defined $OLD_PFILES) { 
    $ENV{'PFILES'} = "$NEW_PFILES".";"."$OLD_PFILES";
} else {
    $ENV{'PFILES'} = $NEW_PFILES 
}

# Construct the nuproducts command:
my $cmd="nuproducts";
$cmd .=" indir=$path infile=$fulname";
$cmd .=" instrument=$FPM steminputs=$evtfile";
$cmd .=" stemout=$STEMOUT";
 
#         srcregionfile=$SRCREGIONFILE \
#         bkgextract=$bkgextract \
#         outdir=$OUTDIR \
#         runmkarf=$runmkarf runmkrmf=$runmkrmf \
#         clobber=$clobber \
#         cleanup=$cleanup \
#         rungrppha=$rungrppha \
#         barycorr=yes clockfile=$clockfile \
#         lcfile=NONE \
#         orbitfile=$ORBFILE \
#         srcra_barycorr=244.9794458 srcdec_barycorr=-15.6402833 \
#         binsize=128 pixbin=2 \
#         imagefile=NONE"








#     INSTRUMENT=FPM${MOD}
#     DATPATH=${OBSID}/event_cl
    

#     STEM=nu`basename $OBSID`
#     infile=${DATPATH}/${STEM}${MOD}01_cl.evt
#     LOGFILE=$OUTDIR/${STEMOUT}.log
#     ORBFILE=$OBSID/auxil/${STEM}_orb.fits
    
#     runmkarf=yes
#     runmkrmf=yes
#     clobber=yes
#     bkgextract=no
#     cleanup=yes
#     rungrppha=yes
    
#     echo $LOCPFILES > $LOGFILE
#     echo ${cmd}
#     ${cmd} >> $LOGFILE








# # Setup a local pfiles directory for this run.
# function headas_locpfiles { export PFILES="$1;$HEADAS/syspfiles"; }







exit;


=head2 parseCommandLineArguments

  Parse the arguments specified upon the command line.

=cut

sub parseCommandLineArguments
{
    my $HELP    = 0;   # Show help overview.
    my $MANUAL    = 0;   # Show manual
    my $VERSION    = 0;   # Show version number and exit.

    #  Parse options.
    #
    GetOptions (
        'help' => \$HELP, 'manual' => \$MANUAL, 'version'=>\$VERSION,
        'binsize=f{1}'=>\$BINSIZE,'region=s'=>\$REGION,
        'usrgti=s'=>\$USRGTI,'barycorr'=>\$BARYCORR,
        'erange=f{2}'=>\@ERANGE, 'outdir=s'=>\$OUTDIR
        );

    pod2usage(1) if $HELP;
    pod2usage(-verbose => 2 ) if $MANUAL;
    
    
    if ( $VERSION )
    {
        my $REVISION      = '0.01';
        $VERSION = join (' ', (split (' ', $REVISION))[2]);
        $VERSION =~ s/,v\b//;
        $VERSION =~ s/(\S+)$/$1/;

        print "run_nuproducts_lightcurve release $RELEASE\n";
        exit;
    }
}



#die "Missing path to file" unless $args{0};
#$evtfile=$args{0};
#say $evtfile;

# Default option checking here:










# for MOD in A B
# do
    
#     LOCPFILES=${OUTDIR}/$$_pfiles${MOD}
#     if [ ! -d $LOCPFILES ]; then
# 	mkdir $LOCPFILES
#     fi
#     headas_locpfiles $LOCPFILES
    
#     SRCREGIONFILE=${OBSID}/event_cl/${REGSTEM}${MOD}.reg
        
#     STEMOUT=${REGSTEM}${MOD}
    

# done
